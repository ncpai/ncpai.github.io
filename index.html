<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªá Th·ªëng Ph√¢n T√≠ch C·∫ßu (N√¢ng C·∫•p)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Tailwind gray-900 */
            color: #F9FAFB; /* Tailwind gray-50 */
        }
        .btn {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .btn:active {
            transform: translateY(1px);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .card-glow-p { box-shadow: 0 0 20px rgba(59, 130, 246, 0.5); }
        .card-glow-b { box-shadow: 0 0 20px rgba(239, 68, 68, 0.5); }
        .card-glow-certain { box-shadow: 0 0 25px rgba(250, 204, 21, 0.7); }
        #bigRoadDisplay {
            display: grid;
            grid-auto-flow: column;
            grid-auto-columns: 2.5rem; /* 40px */
            gap: 2px;
            overflow-x: auto;
            padding: 8px;
            scrollbar-width: thin;
            scrollbar-color: #4B5563 #1F2937;
        }
        .road-col {
            display: grid;
            grid-auto-rows: 2.5rem; /* 40px */
            gap: 2px;
        }
        .road-item {
            width: 2.5rem; height: 2.5rem; border-radius: 9999px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 1.125rem; color: white;
            animation: fadeIn 0.5s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        /* Modal and Toast styles */
        .modal-backdrop {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex; align-items: center; justify-content: center;
            z-index: 50; animation: fadeIn 0.3s ease;
        }
        .modal-content {
            background-color: #1f2937; /* gray-800 */
            padding: 1.5rem; border-radius: 1rem;
            width: 90%; max-width: 400px;
            animation: slideIn 0.3s ease-out;
            border: 1px solid #374151; /* gray-700 */
        }
        .toast-notification {
            position: fixed; top: 20px; right: 20px;
            background-color: #1f2937; color: white;
            padding: 1rem 1.5rem; border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3);
            z-index: 100; animation: slideDown 0.5s ease;
            border-left: 4px solid;
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-20px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-100%); }
            to { opacity: 1; transform: translateY(0); }
        }
        #sessionManagementContent {
            transition: max-height 0.5s ease-in-out;
            overflow: hidden;
        }
        .sim-log-item {
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
            color: white;
            text-align: center;
        }
        #simLog {
            display: grid;
            gap: 4px;
            max-height: 110px; /* Gi·ªõi h·∫°n chi·ªÅu cao */
            overflow-y: auto;  /* Th√™m thanh cu·ªôn khi c·∫ßn */
            padding-right: 5px; /* Th√™m kho·∫£ng tr·ªëng cho thanh cu·ªôn */
            scrollbar-width: thin;
            scrollbar-color: #4B5563 #1F2937;
        }
        
        /* S·ª¨A L·ªñI: Di chuy·ªÉn keyframes v√†o ƒë√¢y */
        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }
    </style>
</head>
<body class="p-4 md:p-8">

<div id="modal-container"></div>
<div id="toast-container"></div>

<div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-6">

    <!-- Left Column: Input & History -->
    <div class="lg:col-span-2 space-y-6">
        <!-- Header -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg text-center">
            <h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-red-400">H·ªá Th·ªëng Ph√¢n T√≠ch C·∫ßu</h1>
            <p class="text-gray-400 mt-2">Ghi nh·ªõ - ƒê·ªëi chi·∫øu - Ph√°n ƒëo√°n</p>
        </div>

        <!-- Session Management -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <div class="flex justify-between items-center cursor-pointer" onclick="toggleSessionManagement()">
                <h2 class="text-xl font-semibold text-blue-300">üìÅ Qu·∫£n L√Ω Phi√™n</h2>
                <button id="toggleSessionBtn" class="text-gray-400 hover:text-white p-1">
                    <svg id="toggleSessionIcon" class="w-6 h-6 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </button>
            </div>
            <div id="sessionManagementContent">
                 <div class="mt-4">
                     <div class="flex flex-col sm:flex-row gap-4 mb-2">
                         <select id="sessionSelector" multiple size="5" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"></select>
                         <div class="grid grid-cols-2 gap-4">
                             <button onclick="createNewSession()" class="btn w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-4 rounded-lg">‚ûï M·ªõi</button>
                             <button onclick="renameSession()" class="btn w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg">‚úèÔ∏è ƒê·ªïi T√™n</button>
                             <button onclick="deleteSelectedSessions()" class="btn w-full bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-4 rounded-lg col-span-2">üóëÔ∏è X√≥a M·ª•c ƒê√£ Ch·ªçn</button>
                              <button onclick="deleteAllSessions()" class="btn w-full bg-red-800 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg col-span-2">üí• X√≥a T·∫•t C·∫£</button>
                         </div>
                     </div>
                      <p class="text-xs text-gray-500 text-center mb-4 sm:text-left">M·∫πo: Gi·ªØ ph√≠m Shift ho·∫∑c Ctrl (Cmd tr√™n Mac) ƒë·ªÉ ch·ªçn nhi·ªÅu phi√™n.</p>
                     <!-- Import/Export -->
                     <div class="flex flex-col sm:flex-row gap-4">
                         <button onclick="exportData()" class="btn w-full bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-4 rounded-lg">üì§ Xu·∫•t D·ªØ Li·ªáu</button>
                         <button onclick="document.getElementById('fileInput').click()" class="btn w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">üì• Nh·∫≠p D·ªØ Li·ªáu</button>
                         <input type="file" id="fileInput" class="hidden" accept=".json" onchange="importData(event)">
                     </div>
                 </div>
            </div>
        </div>

        <!-- CH·ªêT ANALYSIS PANEL -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-purple-300">üîê Ch·ªët Ph√°n Quy·∫øt (T·ªïng H·ª£p 7 Bi·ªÉu ƒê·ªì)</h2>
            
            <div id="finalChotResult" class="text-center bg-gray-900 py-6 rounded-lg border-2 border-purple-500 mb-4 transition-all duration-300">
                <p class="text-lg text-gray-400 mb-2">ƒê·ªÅ xu·∫•t "CH·ªêT":</p>
                <p class="text-3xl font-extrabold text-gray-400">... Ch·ªù t√≠n hi·ªáu ...</p>
            </div>

            <div class="space-y-1" id="chotAnalysisDetails">
                <!-- Rows will be generated by JS -->
                <p class="text-gray-500 text-center py-4">ƒêang t·∫£i d·ªØ li·ªáu ph√¢n t√≠ch...</p>
            </div>
        </div>

        <!-- Input Section -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-blue-300">üé≤ Nh·∫≠p K·∫øt Qu·∫£ V√°n Hi·ªán T·∫°i</h2>
            <div class="grid grid-cols-2 gap-4 mb-4">
                <button onclick="addResult('P')" class="btn bg-blue-600 hover:bg-blue-500 text-white font-bold py-6 rounded-lg text-2xl"><span>üë§</span> PLAYER</button>
                <button onclick="addResult('B')" class="btn bg-red-600 hover:bg-red-500 text-white font-bold py-6 rounded-lg text-2xl"><span>üè¶</span> BANKER</button>
            </div>
            <div class="flex gap-4">
                <button onclick="undoLast()" class="btn flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg">‚Ü©Ô∏è Ho√†n T√°c</button>
                <button onclick="showCustomConfirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ v√† th·ªëng k√™ c·ªßa phi√™n n√†y kh√¥ng?', clearCurrentSessionHistory)" class="btn flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg">üóëÔ∏è X√≥a L·ªãch S·ª≠</button>
            </div>
        </div>

        <!-- Verdict Stats Table -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <h2 class="text-xl font-semibold mb-2 text-indigo-300">‚öñÔ∏è Th·ªëng K√™ Ph√°n Quy·∫øt (Phi√™n)</h2>
            <div class="mt-4 space-y-2" id="verdictStatsTable">
                <!-- Rows will be generated by JS -->
            </div>
        </div>
        
        <!-- Confidence Stats Table -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <h2 class="text-xl font-semibold mb-2 text-green-300">üìä Th·ªëng K√™ ƒê·ªô Tin C·∫≠y (Phi√™n)</h2>
            <div id="confidenceRecommendation" class="my-4 p-3 bg-gray-900 rounded-lg text-center"></div>
            <div class="space-y-2" id="confidenceStatsTable"></div>
        </div>

        <!-- History Display -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-blue-300">üìú B·∫£ng C·∫ßu Big Road</h2>
                <span class="text-gray-400 font-medium">T·ªïng: <span id="totalGames">0</span> v√°n</span>
            </div>
            <div class="bg-gray-900 rounded-lg min-h-[280px] border border-gray-700">
                <div id="bigRoadDisplay">
                    <p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Right Column: Analysis & Stats -->
    <div class="space-y-6">
        <!-- Accuracy Stats -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-green-300">üéØ Th·ªëng K√™ (Phi√™n Hi·ªán T·∫°i)</h2>
            <div class="space-y-4">
                <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                    <span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span>
                    <span id="accuracyRate" class="text-2xl font-bold text-green-400">0.0%</span>
                </div>
                <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                    <span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span>
                    <div><span id="correctPredictions" class="text-lg font-semibold text-white">0</span><span class="text-gray-400">/</span><span id="totalPredictions" class="text-lg font-semibold text-white">0</span></div>
                </div>
            </div>
        </div>

        <!-- Global Accuracy Stats -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-cyan-300">üåê Th·ªëng K√™ (To√†n C·ª•c)</h2>
            <div class="space-y-4">
                <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                    <span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span>
                    <span id="globalAccuracyRate" class="text-2xl font-bold text-cyan-400">0.0%</span>
                </div>
                <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                    <span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span>
                    <div><span id="globalCorrectPredictions" class="text-lg font-semibold text-white">0</span><span class="text-gray-400">/</span><span id="globalTotalPredictions" class="text-lg font-semibold text-white">0</span></div>
                </div>
            </div>
        </div>
        
        <!-- Pattern Analysis -->
        <div id="analysis-card" class="bg-gray-800 p-6 rounded-2xl shadow-lg transition-shadow duration-500">
            <h2 class="text-xl font-semibold mb-4 text-yellow-300">üß† Ph√°n Quy·∫øt (Ph√¢n T√≠ch T·ªïng H·ª£p)</h2>
            <div id="analysisResult" class="space-y-4">
                <p class="text-gray-400 text-center py-8">C·∫ßn √≠t nh·∫•t 10 k·∫øt qu·∫£ ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√¢n t√≠ch...</p>
            </div>
        </div>

        <!-- SIMULATION PANEL -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-orange-300">üí∞ M√¥ Ph·ªèng C∆∞·ª£c</h2>
            <div class="space-y-4">
                <div>
                    <label for="baseBet" class="block text-sm font-medium text-gray-300 mb-1">M·ª©c c∆∞·ª£c c∆° b·∫£n</label>
                    <input type="number" id="baseBet" value="10" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-orange-500 focus:outline-none">
                </div>
                <div>
                    <label for="stopLossLevel" class="block text-sm font-medium text-gray-300 mb-1">Ng∆∞·ª°ng c·∫Øt l·ªó (s·ªë l·∫ßn thua)</label>
                    <input type="number" id="stopLossLevel" value="4" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-orange-500 focus:outline-none">
                </div>
                 <div>
                    <label for="displayColumns" class="block text-sm font-medium text-gray-300 mb-1">S·ªë c·ªôt hi·ªÉn th·ªã</label>
                    <input type="number" id="displayColumns" value="6" min="2" max="9" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-orange-500 focus:outline-none">
                </div>
                 <div>
                     <label class="block text-sm font-medium text-gray-300 mb-1">Ch·∫ø ƒë·ªô c∆∞·ª£c</label>
                     <div class="flex gap-4">
                         <div class="flex-1">
                             <input type="radio" id="simModeFollow" name="simMode" value="follow" class="hidden peer" checked>
                             <label for="simModeFollow" class="block w-full text-center py-2 px-3 rounded-lg bg-gray-700 border-2 border-gray-600 cursor-pointer peer-checked:border-green-500 peer-checked:bg-green-900 peer-checked:text-green-300">Theo</label>
                         </div>
                         <div class="flex-1">
                             <input type="radio" id="simModeAgainst" name="simMode" value="against" class="hidden peer">
                             <label for="simModeAgainst" class="block w-full text-center py-2 px-3 rounded-lg bg-gray-700 border-2 border-gray-600 cursor-pointer peer-checked:border-red-500 peer-checked:bg-red-900 peer-checked:text-red-300">Ng∆∞·ª£c</label>
                         </div>
                     </div>
                 </div>
                 <div class="mt-4 bg-gray-900 p-4 rounded-lg space-y-3">
                     <div class="flex justify-between items-center text-sm">
                         <span class="font-medium text-gray-400">L√£i/L·ªó Phi√™n:</span>
                         <span id="simProfitLoss" class="font-bold text-lg text-white">0</span>
                     </div>
                     <div class="flex justify-between items-center text-sm">
                         <span class="font-medium text-gray-400">C∆∞·ª£c Ti·∫øp Theo:</span>
                         <span id="simNextBet" class="font-bold text-lg text-yellow-300">0</span>
                     </div>
                     <div class="text-sm">
                         <span class="font-medium text-gray-400">Chu·ªói C∆∞·ª£c:</span>
                         <div id="simLog" class="mt-1">
                             <p class="text-gray-500 text-xs col-span-6 text-center">Ch∆∞a c√≥...</p>
                         </div>
                     </div>
                 </div>
            </div>
        </div>

    </div>
</div>

<script>
// --- CORE LOGIC: PATTERN MATCHER (Standard) ---
class PatternMatcher {
    constructor() {
        this.MIN_HISTORY_FOR_ANALYSIS = 10;
        this.MIN_PATTERN_LENGTH = 10;
        this.MAX_PATTERN_LENGTH = 15;
        this.MIN_CERTAIN_OCCURRENCES = 5;
    }
    calculateSimilarity(arr1, arr2) {
        if (arr1.length !== arr2.length || arr1.length === 0) return 0;
        const matches = arr1.filter((item, index) => item === arr2[index]).length;
        return matches / arr1.length;
    }
    findPatternOccurrences(pattern, allHistory) {
        const occurrences = [];
        const reversedPattern = [...pattern].reverse();
        for (const session of allHistory) {
            const sessionHistory = session.history || [];
            if (sessionHistory.length < pattern.length + 1) continue;
            for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {
                const segment = sessionHistory.slice(i, i + pattern.length);
                const nextResult = sessionHistory[i + pattern.length];
                const similarity = this.calculateSimilarity(pattern, segment);
                if (similarity >= 0.9) occurrences.push({ type: 'similar', next: nextResult, similarity });
                const reverseSimilarity = this.calculateSimilarity(reversedPattern, segment);
                if (reverseSimilarity >= 0.9) occurrences.push({ type: 'reversed', next: nextResult, similarity: reverseSimilarity });
            }
        }
        return occurrences;
    }
    getPredictionForPattern(pattern, allHistoricalSessions) {
        const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);
        if (occurrences.length === 0) return { prediction: null };
        const votes = { P: 0, B: 0 };
        occurrences.forEach(match => { if (votes[match.next] !== undefined) votes[match.next] += match.similarity; });
        const totalVotes = votes.P + votes.B;
        if (totalVotes === 0) return { prediction: null };
        const predictedWinner = votes.P > votes.B ? 'P' : 'B';
        const confidence = (Math.max(votes.P, votes.B) / totalVotes) * 100;
        return { prediction: predictedWinner, confidence, votes, totalOccurrences: occurrences.length };
    }
    findCertainPrediction(currentHistory, allHistoricalSessions) {
        for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {
            const pattern = currentHistory.slice(-len);
            const patternString = pattern.join('');
            const occurrences = [];
            for (const session of allHistoricalSessions) {
                const sessionHistory = session.history || [];
                if (sessionHistory.length < pattern.length + 1) continue;
                for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {
                    const segment = sessionHistory.slice(i, i + pattern.length);
                    if (segment.join('') === patternString) {
                        occurrences.push(sessionHistory[i + pattern.length]);
                    }
                }
            }
            if (occurrences.length >= this.MIN_CERTAIN_OCCURRENCES && new Set(occurrences).size === 1) {
                return {
                    prediction: occurrences[0],
                    recommendation: 'TAY CH·∫ÆC CH·∫ÆN',
                    analysisText: `T√¨m th·∫•y ${occurrences.length} l·∫ßn xu·∫•t hi·ªán ch√≠nh x√°c c·ªßa h√¨nh c·∫ßu n√†y trong l·ªãch s·ª≠.\nT·∫•t c·∫£ ƒë·ªÅu cho k·∫øt qu·∫£ ti·∫øp theo l√†: ${occurrences[0]}`,
                    confidence: 100,
                    isCertain: true
                };
            }
        }
        return null;
    }
    analyzeCurrentStreak(currentHistory) {
        if (currentHistory.length < 2) return { type: 'none', length: currentHistory.length };
        const last = currentHistory[currentHistory.length - 1];
        if (last === currentHistory[currentHistory.length - 2]) {
            let length = 0;
            for (let i = currentHistory.length - 1; i >= 0; i--) {
                if (currentHistory[i] === last) length++; else break;
            }
            return { type: 'b·ªát', length, value: last };
        } else {
            let length = 0;
            for (let i = currentHistory.length - 1; i >= 1; i--) {
                if (currentHistory[i] !== currentHistory[i-1]) length++; else break;
            }
            return { type: '1-1', length: length + 1 };
        }
    }
    getPrediction(currentHistory, allHistoricalSessions, { optimalLength = null, lengthPerformance = {} } = {}) {
        if (currentHistory.length < this.MIN_HISTORY_FOR_ANALYSIS) {
            return { prediction: null, analysisText: `C·∫ßn √≠t nh·∫•t ${this.MIN_HISTORY_FOR_ANALYSIS} k·∫øt qu·∫£...`, confidence: 0, isCertain: false };
        }
        if (optimalLength && currentHistory.length >= optimalLength) {
            const pattern = currentHistory.slice(-optimalLength);
            const result = this.getPredictionForPattern(pattern, allHistoricalSessions);
            if (result.prediction) {
                const perf = lengthPerformance[optimalLength] || { wins: 0, total: 0 };
                
                if (perf.wins > perf.total) {
                    perf.wins = perf.total; 
                }
                
                const rate = perf.total > 0 ? (perf.wins / perf.total * 100).toFixed(1) : 'N/A';
                return {
                    prediction: result.prediction, recommendation: 'THEO CHI·ªÄU D√ÄI T·ªêI ∆ØU',
                    analysisText: `S·ª≠ d·ª•ng chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u: ${optimalLength} v√°n.\n(T·ª∑ l·ªá th·∫Øng c·ªßa chi·ªÅu d√†i n√†y: ${rate}% - ${perf.wins}/${perf.total})\n\nL·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${result.votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${result.votes.B.toFixed(1)} ƒëi·ªÉm`,
                    confidence: result.confidence, isCertain: false
                };
            }
        }
        const certainPrediction = this.findCertainPrediction(currentHistory, allHistoricalSessions);
        if (certainPrediction) return certainPrediction;
        const allMatches = [];
        for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {
            const pattern = currentHistory.slice(-len);
            const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);
            if (occurrences.length > 0) {
                allMatches.push(...occurrences);
                break;
            }
        }
        if (allMatches.length === 0) return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª±.', confidence: 0, isCertain: false };
        const votes = { P: 0, B: 0 };
        allMatches.forEach(match => { if (votes[match.next] !== undefined) votes[match.next] += match.similarity; });
        const totalVotes = votes.P + votes.B;
        if (totalVotes === 0) return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª±.', confidence: 0, isCertain: false };
        const predictedWinner = votes.P > votes.B ? 'P' : 'B';
        const maxConfidence = (Math.max(votes.P, votes.B) / totalVotes) * 100;
        const analysisTextPrefix = `T√¨m th·∫•y ${allMatches.length} h√¨nh c·∫ßu t∆∞∆°ng t·ª±. L·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${votes.B.toFixed(1)} ƒëi·ªÉm`;
        const streakInfo = this.analyzeCurrentStreak(currentHistory);
        let recommendation = 'THEO PH√ÇN T√çCH L·ªäCH S·ª¨';
        if (streakInfo.type === 'b·ªát') recommendation = predictedWinner === streakInfo.value ? `THEO B·ªÜT (${streakInfo.value}x${streakInfo.length})` : `B·∫∫ C·∫¶U B·ªÜT (${streakInfo.value}x${streakInfo.length})`;
        else if (streakInfo.type === '1-1') recommendation = predictedWinner !== currentHistory[currentHistory.length - 1] ? `THEO C·∫¶U 1-1 (D√†i ${streakInfo.length})` : `B·∫∫ C·∫¶U 1-1 (D√†i ${streakInfo.length})`;
        return { prediction: predictedWinner, recommendation, analysisText: `${analysisTextPrefix}\n\nüèÜ ƒê·ªô tin c·∫≠y: ${maxConfidence.toFixed(1)}%`, confidence: maxConfidence, isCertain: false };
    }
}

// --- GLOBAL STATE ---
let state = {
    currentSessionId: null,
    sessions: {},
    matcher: new PatternMatcher(),
    currentPrediction: null, // Stores { prediction: 'P'/'B', confidence: number } from core matcher
    originalSystemPrediction: null, // <<< M·ªöI: L∆∞u tr·ªØ P/B g·ªëc tr∆∞·ªõc khi verdict c√≥ th·ªÉ ƒë·∫£o ng∆∞·ª£c
    currentFinalPrediction: null, // Stores { verdict: 'follow'/'against'/'neutral', prediction: 'P'/'B' } after verdict logic
    goldenRange: null,
    deathRange: null,
    sessionConfidenceRanges: [],
    confidenceSequenceData: {}
};

// --- STATS CALCULATION ---
function getPredictionStats(predictions) {
    const total = predictions.length;
    if (total === 0) return { rate: 0, correct: 0, total: 0 };
    const correct = predictions.filter(p => p.predicted === p.actual).length;
    return { rate: (correct / total) * 100, correct, total };
}

function calculateConfidenceRangeStats(predictions) {
    const ranges = [{min:50,max:60},{min:60,max:70},{min:70,max:80},{min:80,max:90},{min:90,max:100}].map(r => ({...r, total:0, wins:0, rate: -1}));
    
    ranges.forEach(range => {
        const predictionsForRange = predictions.filter(p => p.confidence >= range.min && (p.confidence < range.max || (range.max === 100 && p.confidence >= 100)));
        range.total = predictionsForRange.length;
        range.wins = predictionsForRange.filter(p => p.predicted === p.actual).length;
        range.rate = range.total > 0 ? ((range.wins / range.total) * 100) : -1;
    });
    return ranges;
}

function getConfidenceSequenceData() {
    const sequenceData = {};
    const rangeDefs = [{min:50,max:60},{min:60,max:70},{min:70,max:80},{min:80,max:90},{min:90,max:100}];

    rangeDefs.forEach(r => {
        const key = `${r.min}-${r.max}`;
        sequenceData[key] = {};
    });

    for (const sessionId in state.sessions) {
        const session = state.sessions[sessionId];
        if (!session.predictions || session.predictions.length === 0) continue;

        const sessionSequences = {};
        rangeDefs.forEach(r => {
            const key = `${r.min}-${r.max}`;
            sessionSequences[key] = [];
        });

        session.predictions.forEach(p => {
            const result = (p.predicted === p.actual) ? 'W' : 'L';
            const foundRange = rangeDefs.find(r => p.confidence >= r.min && (p.confidence < r.max || (r.max === 100 && p.confidence >= 100)));
            if (foundRange) {
                const key = `${foundRange.min}-${foundRange.max}`;
                sessionSequences[key].push(result);
            }
        });

        for (const key in sessionSequences) {
            if (sessionSequences[key].length > 0) {
                sequenceData[key][sessionId] = sessionSequences[key].join('');
            }
        }
    }
    return sequenceData;
}

// --- SELF-VERDICT LOGIC ---
function getCurrentStreak(sequence) {
    if (!sequence) return { type: null, length: 0 };
    const lastChar = sequence.slice(-1);
    let length = 0;
    for (let i = sequence.length - 1; i >= 0; i--) {
        if (sequence[i] === lastChar) {
            length++;
        } else {
            break;
        }
    }
    return { type: lastChar, length };
}

function calculateStreakStats(sequencesObject) {
    let maxW = 0, maxL = 0;
    const allSequences = Object.values(sequencesObject).join('');
    if (!allSequences) return { maxW: 0, maxL: 0 };

    const winStreaks = allSequences.match(/W+/g) || [];
    if (winStreaks.length > 0) {
        maxW = Math.max(...winStreaks.map(s => s.length));
    }

    const lossStreaks = allSequences.match(/L+/g) || [];
    if (lossStreaks.length > 0) {
        maxL = Math.max(...lossStreaks.map(s => s.length));
    }
    return { maxW, maxL };
}

function getFinalVerdict(context) {
    const { prediction, confidence, sequenceData, currentSessionId } = context;
    if (!prediction) {
        return { verdict: 'neutral', explanation: 'Ch∆∞a c√≥ ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ƒë∆∞a ra ph√°n quy·∫øt.' };
    }

    const rangeDefs = [{min:50,max:60},{min:60,max:70},{min:70,max:80},{min:80,max:90},{min:90,max:100}];
    const foundRange = rangeDefs.find(r => confidence >= r.min && (confidence < r.max || (r.max === 100 && confidence >= 100)));
    
    if (!foundRange) {
        return { verdict: 'neutral', explanation: 'Ph√°n ƒëo√°n kh√¥ng thu·ªôc kho·∫£ng tin c·∫≠y n√†o.' };
    }

    const rangeKey = `${foundRange.min}-${foundRange.max}`;
    const historicalSequences = { ...sequenceData[rangeKey] };
    const currentSequenceStr = historicalSequences[currentSessionId] || "";
    delete historicalSequences[currentSessionId];

    // --- Tier 1: Longest possible pattern search (Primary) ---
    const maxLen = Math.min(currentSequenceStr.length, 5); 
    for (let len = maxLen; len >= 2; len--) {
        const patternToSearch = currentSequenceStr.slice(-len);
        let wins = 0, losses = 0;
        for (const sessionId in historicalSequences) {
            const history = historicalSequences[sessionId];
            let i = -1;
            while ((i = history.indexOf(patternToSearch, i + 1)) !== -1) {
                const nextCharIndex = i + patternToSearch.length;
                if (nextCharIndex < history.length) {
                    if (history[nextCharIndex] === 'W') wins++; else losses++;
                }
            }
        }
        if (wins + losses >= 2) { 
            const patternText = patternToSearch.replace(/W/g, 'Th·∫Øng-').replace(/L/g, 'Thua-').slice(0, -1);
            if (wins > losses) return { verdict: 'follow', explanation: `N√™n theo. Quy lu·∫≠t d√†i ${len} v√°n c·ªßa kho·∫£ng n√†y cho th·∫•y sau chu·ªói ${patternText}, k·∫øt qu·∫£ th∆∞·ªùng l√† Th·∫Øng.` };
            if (losses > wins) return { verdict: 'against', explanation: `N√™n ƒëi ng∆∞·ª£c l·∫°i. Quy lu·∫≠t d√†i ${len} v√°n c·ªßa kho·∫£ng n√†y cho th·∫•y sau chu·ªói ${patternText}, k·∫øt qu·∫£ th∆∞·ªùng l√† Thua.` };
        }
    }

    // --- Tier 2: Max Streak Analysis (Secondary) ---
    const currentStreak = getCurrentStreak(currentSequenceStr);
    const streakStats = calculateStreakStats(historicalSequences);
    if (currentStreak.type === 'W' && streakStats.maxW > 0 && currentStreak.length >= streakStats.maxW) {
        return { verdict: 'against', explanation: `N√™n ƒëi ng∆∞·ª£c l·∫°i. Chu·ªói Th·∫Øng hi·ªán t·∫°i (${currentStreak.length}) ƒë√£ b·∫±ng ho·∫∑c v∆∞·ª£t ng∆∞·ª°ng t·ªëi ƒëa (${streakStats.maxW}) trong l·ªãch s·ª≠ c·ªßa kho·∫£ng n√†y.` };
    }
    if (currentStreak.type === 'L' && streakStats.maxL > 0 && currentStreak.length >= streakStats.maxL) {
        return { verdict: 'follow', explanation: `N√™n theo. Chu·ªói Thua hi·ªán t·∫°i (${currentStreak.length}) ƒë√£ b·∫±ng ho·∫∑c v∆∞·ª£t ng∆∞·ª°ng t·ªëi ƒëa (${streakStats.maxL}) trong l·ªãch s·ª≠ c·ªßa kho·∫£ng n√†y.` };
    }

    // --- Tier 3: Cross-range "Absolute" pattern (Fallback) ---
    const absolutePatternLength = Math.min(currentSequenceStr.length, 3);
    if (absolutePatternLength >= 2) {
        const patternToSearch = currentSequenceStr.slice(-absolutePatternLength);
        let crossWins = 0, crossLosses = 0;
        const MIN_ABSOLUTE_OCCURRENCES = 4;

        for (const key in sequenceData) {
            const otherRangeSequences = sequenceData[key];
            for (const sessionId in otherRangeSequences) {
                if (sessionId === currentSessionId) continue;
                const history = otherRangeSequences[sessionId];
                let i = -1;
                while ((i = history.indexOf(patternToSearch, i + 1)) !== -1) {
                    const nextCharIndex = i + patternToSearch.length;
                    if (nextCharIndex < history.length) {
                        if (history[nextCharIndex] === 'W') crossWins++;
                        else crossLosses++;
                    }
                }
            }
        }
        
        const patternText = patternToSearch.replace(/W/g, 'Th·∫Øng-').replace(/L/g, 'Thua-').slice(0, -1);
        if (crossWins + crossLosses >= MIN_ABSOLUTE_OCCURRENCES) {
            if (crossWins === 0) return { verdict: 'against', explanation: `N√™n ƒëi ng∆∞·ª£c l·∫°i. Quy lu·∫≠t tuy·ªát ƒë·ªëi (${patternText} -> Thua) ƒë∆∞·ª£c t√¨m th·∫•y tr√™n to√†n b·ªô l·ªãch s·ª≠.` };
            if (crossLosses === 0) return { verdict: 'follow', explanation: `N√™n theo. Quy lu·∫≠t tuy·ªát ƒë·ªëi (${patternText} -> Th·∫Øng) ƒë∆∞·ª£c t√¨m th·∫•y tr√™n to√†n b·ªô l·ªãch s·ª≠.` };
        }
    }
    
    return { verdict: 'neutral', explanation: 'Kh√¥ng t√¨m th·∫•y quy lu·∫≠t bi·ªÉu ƒë·ªì r√µ r√†ng trong l·ªãch s·ª≠.' };
}


// --- UI UPDATE FUNCTIONS ---
function updateBigRoadUI() {
    const history = state.sessions[state.currentSessionId]?.history || [];
    const roadDiv = document.getElementById('bigRoadDisplay');
    document.getElementById('totalGames').textContent = history.length;
    if (history.length === 0) {
        roadDiv.innerHTML = '<p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>';
        roadDiv.style.display = 'block';
        return;
    }
    roadDiv.style.display = 'grid';
    roadDiv.innerHTML = '';
    const columns = [];
    if (history.length > 0) {
        let currentCol = [history[0]];
        for (let i = 1; i < history.length; i++) {
            if (history[i] === history[i-1]) currentCol.push(history[i]);
            else { columns.push(currentCol); currentCol = [history[i]]; }
        }
        columns.push(currentCol);
    }
    columns.forEach(colData => {
        const colDiv = document.createElement('div');
        colDiv.className = 'road-col';
        colData.forEach(item => {
            const itemDiv = document.createElement('div');
            itemDiv.className = `road-item ${item === 'P' ? 'bg-blue-600' : 'bg-red-600'}`;
            itemDiv.textContent = item;
            colDiv.appendChild(itemDiv);
        });
        roadDiv.appendChild(colDiv);
    });
    roadDiv.scrollLeft = roadDiv.scrollWidth;
}
function updateAccuracyUI() {
    const predictions = state.sessions[state.currentSessionId]?.predictions || [];
    const stats = getPredictionStats(predictions);
    document.getElementById('accuracyRate').textContent = `${stats.rate.toFixed(1)}%`;
    document.getElementById('correctPredictions').textContent = stats.correct;
    document.getElementById('totalPredictions').textContent = stats.total;
}
function updateGlobalAccuracyUI() {
    const allPredictions = Object.values(state.sessions).flatMap(s => s.predictions || []);
    const stats = getPredictionStats(allPredictions);
    document.getElementById('globalAccuracyRate').textContent = `${stats.rate.toFixed(1)}%`;
    document.getElementById('globalCorrectPredictions').textContent = stats.correct;
    document.getElementById('globalTotalPredictions').textContent = stats.total;
}
function updateAnalysisUI() {
    const session = state.sessions[state.currentSessionId] || { history: [], optimalLength: null, lengthPerformance: {} };
    const { prediction, recommendation, analysisText, confidence, isCertain } = state.matcher.getPrediction(session.history, Object.values(state.sessions), {
        optimalLength: session.optimalLength,
        lengthPerformance: session.lengthPerformance
    });
    // L∆∞u tr·ªØ d·ª± ƒëo√°n g·ªëc P/B v√† ƒë·ªô tin c·∫≠y
    state.currentPrediction = { prediction, confidence };
    state.originalSystemPrediction = prediction; // <<< M·ªöI: L∆∞u P/B g·ªëc t·∫°i ƒë√¢y

    const verdictContext = {
        prediction, confidence,
        sequenceData: state.confidenceSequenceData,
        currentSessionId: state.currentSessionId
    };
    const finalVerdict = getFinalVerdict(verdictContext);

    let finalPredictionForDisplay = prediction; // D·ª± ƒëo√°n hi·ªÉn th·ªã tr√™n UI ch√≠nh
    if (finalVerdict.verdict === 'against' && !isCertain) {
        finalPredictionForDisplay = prediction === 'P' ? 'B' : 'P';
    }
    
    // L∆∞u tr·ªØ ph√°n quy·∫øt cu·ªëi c√πng v√† d·ª± ƒëo√°n P/B cu·ªëi c√πng (sau khi √°p d·ª•ng verdict)
    state.currentFinalPrediction = { verdict: finalVerdict.verdict, prediction: finalPredictionForDisplay };

    let verdictHTML = `<div class="mt-3 p-3 text-center bg-gray-800 rounded-lg text-sm font-semibold ${
        finalVerdict.verdict === 'follow' || isCertain ? 'text-green-300' :
        finalVerdict.verdict === 'against' ? 'text-red-300' : 'text-yellow-300'
    }"><strong>Ph√°n Quy·∫øt:</strong> ${isCertain ? 'Tay ch·∫Øc ch·∫Øn, lu√¥n ∆∞u ti√™n theo h·ªá th·ªëng.' : finalVerdict.explanation}</div>`;

    let recommendationText = recommendation;
    if(finalVerdict.verdict === 'against' && !isCertain) {
        recommendationText = 'ƒêI NG∆Ø·ª¢C H·ªÜ TH·ªêNG';
    }

    const analysisResultDiv = document.getElementById('analysisResult'), analysisCard = document.getElementById('analysis-card');
    analysisCard.classList.remove('card-glow-p', 'card-glow-b', 'card-glow-certain');
    let optimalLengthDisplay = session.optimalLength ? `<div class="mb-4 p-3 bg-gray-900 rounded-lg text-center text-cyan-300 text-sm"><span class="font-semibold">Chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u:</span><span class="text-lg font-bold ml-2">${session.optimalLength}</span></div>` : '';
    
    if (prediction) { // A prediction was made
        let predictionBlockHTML = `
            <div class="text-center bg-gray-900 py-6 rounded-lg border-2 ${finalPredictionForDisplay === 'P' ? 'border-blue-500' : 'border-red-500'}">
                <p class="text-lg text-gray-400 mb-2">ƒê·ªÅ xu·∫•t cu·ªëi c√πng:</p>
                <p class="text-3xl font-extrabold ${finalPredictionForDisplay === 'P' ? 'text-blue-400' : 'text-red-400'}">${recommendationText}</p>
                <p class="text-4xl font-bold mt-2">${finalPredictionForDisplay === 'P' ? 'üë§ PLAYER' : 'üè¶ BANKER'}</p>
                ${verdictHTML}
            </div>
            
            <div class="bg-gray-700 p-4 rounded-lg mt-4">
                <p class="font-semibold text-gray-300">Ph√¢n t√≠ch ban ƒë·∫ßu c·ªßa h·ªá th·ªëng:</p>
                <p class="text-gray-400 whitespace-pre-wrap text-sm">${analysisText}</p>
            </div>
        `;

        if (isCertain) {
            // ƒê·ªëi v·ªõi 'TAY CH·∫ÆC CH·∫ÆN', d·ª± ƒëo√°n hi·ªÉn th·ªã lu√¥n l√† d·ª± ƒëo√°n g·ªëc
            predictionBlockHTML = `
            <div class="text-center bg-yellow-800 bg-opacity-50 py-6 rounded-lg border-2 border-yellow-400">
                <p class="text-lg text-yellow-300 mb-2 animate-pulse">ƒê·ªÅ Xu·∫•t Ch·∫Øc Ch·∫Øn (L·ªãch s·ª≠):</p>
                <p class="text-3xl font-extrabold text-yellow-300">${recommendation}</p>
                <p class="text-4xl font-bold mt-2">${prediction === 'P' ? 'üë§ PLAYER' : 'üè¶ BANKER'}</p>
                ${verdictHTML}
            </div>
             <div class="bg-gray-700 p-4 rounded-lg mt-4">
                <p class="font-semibold text-gray-300">Ph√¢n t√≠ch ban ƒë·∫ßu c·ªßa h·ªá th·ªëng:</p>
                <p class="text-gray-400 whitespace-pre-wrap text-sm">${analysisText}</p>
            </div>
            `;
            analysisCard.classList.add('card-glow-certain');
        } else {
            analysisCard.classList.add(finalPredictionForDisplay === 'P' ? 'card-glow-p' : 'card-glow-b');
        }
        
        analysisResultDiv.innerHTML = optimalLengthDisplay + predictionBlockHTML;

    } else {
        analysisResultDiv.innerHTML = `${optimalLengthDisplay}<p class="text-gray-400 text-center py-8 whitespace-pre-wrap">${analysisText}</p>`;
    }
}


function updateConfidenceStatsUI() {
    if (!state.currentSessionId || !state.sessions[state.currentSessionId]) return;
    
    const sessionPredictions = state.sessions[state.currentSessionId].predictions || [];
    state.sessionConfidenceRanges = calculateConfidenceRangeStats(sessionPredictions);
    state.confidenceSequenceData = getConfidenceSequenceData();

    const currentConfidence = state.currentPrediction?.confidence;
    const previousConfidence = sessionPredictions.length > 0 ? sessionPredictions[sessionPredictions.length - 1].confidence : null;

    let bestRange = null, maxRate = -1;
    let worstRange = null, minRate = 101;

    state.sessionConfidenceRanges.forEach(range => {
        if (range.total >= 3 && range.rate > maxRate) { 
            maxRate = range.rate; 
            bestRange = range; 
        }
        if (range.total >= 3 && range.rate !== -1 && range.rate < minRate) {
            minRate = range.rate;
            worstRange = range;
        }

        const predictionsForRange = sessionPredictions.filter(p => p.confidence >= range.min && (p.confidence < range.max || (p.confidence >= 100 && range.max === 100)));
        let trendIndicator = '', streak = 0;
        if (predictionsForRange.length >= 1) {
            const lastWin = (predictionsForRange.slice(-1)[0].predicted === predictionsForRange.slice(-1)[0].actual);
            for (let i = predictionsForRange.length - 1; i >= 0; i--) {
                if ((predictionsForRange[i].predicted === predictionsForRange[i].actual) === lastWin) streak++; else break;
            }
            if(streak >= 1) trendIndicator = `<span class="flex items-center ${lastWin ? 'text-green-400' : 'text-red-400'} ml-1.5">${lastWin ? '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd"></path></svg>' : '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>'}<span class="font-bold text-xs">${streak}</span></span>`;
        }
        range.trendIndicator = trendIndicator;
    });
    state.goldenRange = bestRange;
    state.deathRange = worstRange;
    
    const recommendationDiv = document.getElementById('confidenceRecommendation');
    let recommendationHTML = '';
    if (bestRange) {
        recommendationHTML += `<p class="text-sm text-yellow-300"><span class="font-bold">‚ú® Kho·∫£ng V√†ng:</span> T·ª∑ l·ªá th·∫Øng cao nh·∫•t l√† <b class="text-green-400">${maxRate.toFixed(1)}%</b> trong kho·∫£ng <b class="text-white">${bestRange.min}%-${bestRange.max}%</b>.</p>`;
    }
    if (worstRange) {
        recommendationHTML += `<p class="text-sm text-yellow-300 mt-1"><span class="font-bold">üíÄ Kho·∫£ng T·ª≠ Th·∫ßn:</span> T·ª∑ l·ªá th·∫Øng th·∫•p nh·∫•t l√† <b class="text-red-400">${minRate.toFixed(1)}%</b> trong kho·∫£ng <b class="text-white">${worstRange.min}%-${worstRange.max}%</b>.</p>`;
    }

    if (!bestRange && !worstRange) {
        recommendationDiv.innerHTML = `<p class="text-sm text-gray-400">Ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ t√¨m kho·∫£ng v√†ng/t·ª≠ th·∫ßn (c·∫ßn t·ªëi thi·ªÉu 3 ph√°n ƒëo√°n trong 1 kho·∫£ng).</p>`;
    } else {
        recommendationDiv.innerHTML = recommendationHTML;
    }
    
    const tableDiv = document.getElementById('confidenceStatsTable');
    let html = `<div class="grid gap-x-2 text-xs font-semibold text-gray-400 px-3" style="grid-template-columns: 2fr 4fr 2fr 2fr 3fr;"><span>Kho·∫£ng</span><span class="text-center">Di·ªÖn Bi·∫øn G·∫ßn ƒê√¢y</span><span class="text-center">T·ªïng</span><span class="text-center">Th·∫Øng</span><span class="text-right">T·ª∑ L·ªá</span></div>`;
    if (sessionPredictions.length === 0 && !currentConfidence) {
        tableDiv.innerHTML = '<p class="text-gray-500 text-center py-4">Ch∆∞a c√≥ d·ªØ li·ªáu th·ªëng k√™.</p>';
    } else {
        state.sessionConfidenceRanges.forEach(range => {
            let highlightClass = 'bg-gray-700 bg-opacity-50';
            if (range === bestRange) {
                highlightClass = 'bg-green-800 bg-opacity-40 border border-green-500';
            } else if (range === worstRange) {
                highlightClass = 'bg-red-800 bg-opacity-40 border border-red-500';
            }

            let indicatorsHTML = '';
            if (currentConfidence && state.currentFinalPrediction?.prediction && currentConfidence >= range.min && (currentConfidence < range.max || (currentConfidence >= 100 && range.max === 100))) {
                const finalPrediction = state.currentFinalPrediction.prediction;
                const sideText = finalPrediction === 'P' ? 'PLAYER' : 'BANKER';
                const sideColor = finalPrediction === 'P' ? 'bg-blue-600' : 'bg-red-600';
                indicatorsHTML += `<span class="ml-2 px-1.5 py-0.5 text-xs rounded font-semibold ${sideColor} text-white" title="ƒê·ªÅ xu·∫•t v√°n hi·ªán t·∫°i">${sideText}</span>`;
            }
            if (previousConfidence && previousConfidence >= range.min && (previousConfidence < range.max || (previousConfidence >= 100 && range.max === 100))) {
                const marginLeft = indicatorsHTML ? 'ml-1' : 'ml-2';
                indicatorsHTML += `<span class="${marginLeft} px-1.5 py-0.5 text-xs rounded font-semibold bg-gray-500 text-white" title="Ph√°n ƒëo√°n v√°n tr∆∞·ªõc">Tr∆∞·ªõc</span>`;
            }
            const predictionsForRange = sessionPredictions.filter(p => p.confidence >= range.min && (p.confidence < range.max || (p.confidence >= 100 && range.max === 100)));
            const displayedPredictions = predictionsForRange.slice(-30);
            let individualBarsHTML = `<div class="flex items-end justify-center gap-px h-5 my-auto overflow-hidden" title="Hi·ªÉn th·ªã t·ªëi ƒëa 30 v√°n g·∫ßn nh·∫•t">`;
            if (displayedPredictions.length > 0) {
                for (const p of displayedPredictions) {
                    const isWin = p.predicted === p.actual;
                    const barClass = isWin ? 'bg-green-500 h-5' : 'bg-red-500 h-2';
                    const title = `ƒê·ªÅ xu·∫•t: ${p.predicted}, Ra: ${p.actual} -> ${isWin ? 'TH·∫ÆNG' : 'THUA'}\nƒê·ªô tin c·∫≠y: ${p.confidence.toFixed(1)}%`;
                    individualBarsHTML += `<div class="flex-shrink-0 w-1 ${barClass} rounded-t-sm" title="${title}"></div>`;
                }
            } else {
                individualBarsHTML += `<div class="w-full text-center"><span class="text-gray-600 text-xs">Ch∆∞a c√≥</span></div>`;
            }
            individualBarsHTML += '</div>';
            html += `<div class="grid gap-x-2 items-center ${highlightClass} p-3 rounded-lg mt-2 text-sm" style="grid-template-columns: 2fr 4fr 2fr 2fr 3fr;">
                <span class="font-medium text-gray-300">${range.min}%-${range.max}%</span>
                ${individualBarsHTML}
                <span class="text-white font-semibold text-center">${range.total}</span>
                <span class="text-green-400 font-semibold text-center">${range.wins}</span>
                <span class="font-bold flex items-center justify-end ${range.rate >= 70 ? 'text-green-400' : (range.rate >= 50 ? 'text-yellow-400' : 'text-red-400')}">
                ${range.rate > -1 ? range.rate.toFixed(1) + '%' : '-'}${range.trendIndicator}${indicatorsHTML}
                </span></div>`;
        });
        tableDiv.innerHTML = html;
    }
}
function updateVerdictStatsUI() {
    if (!state.currentSessionId || !state.sessions[state.currentSessionId]) return;

    const verdictPredictions = state.sessions[state.currentSessionId].verdictPredictions || [];
    const tableDiv = document.getElementById('verdictStatsTable');

    const stats = {
        follow: { total: 0, wins: 0, predictions: [] },
        against: { total: 0, wins: 0, predictions: [] }
    };

    verdictPredictions.forEach(p => {
        if (p.verdict === 'follow') {
            stats.follow.total++;
            stats.follow.predictions.push(p);
            if (p.predicted === p.actual) stats.follow.wins++;
        } else if (p.verdict === 'against') {
            stats.against.total++;
            stats.against.predictions.push(p);
            if (p.predicted === p.actual) stats.against.wins++;
        }
    });

    let html = `<div class="grid gap-x-2 text-xs font-semibold text-gray-400 px-3" style="grid-template-columns: 2fr 4fr 2fr 2fr 3fr;"><span>Ph√°n Quy·∫øt</span><span class="text-center">Di·ªÖn Bi·∫øn G·∫ßn ƒê√¢y</span><span class="text-center">T·ªïng</span><span class="text-center">Th·∫Øng</span><span class="text-right">T·ª∑ L·ªá</span></div>`;

    if (verdictPredictions.length === 0) {
        tableDiv.innerHTML = '<p class="text-gray-500 text-center py-4">Ch∆∞a c√≥ d·ªØ li·ªáu ph√°n quy·∫øt.</p>';
        return;
    }

    const createRowHTML = (label, data) => {
        const rate = data.total > 0 ? (data.wins / data.total) * 100 : -1;
        
        const displayedPredictions = data.predictions.slice(-30);
        let individualBarsHTML = `<div class="flex items-end justify-center gap-px h-5 my-auto overflow-hidden" title="Hi·ªÉn th·ªã t·ªëi ƒëa 30 v√°n g·∫ßn nh·∫•t">`;
        if (displayedPredictions.length > 0) {
            displayedPredictions.forEach(p => {
                const isWin = p.predicted === p.actual;
                const barClass = isWin ? 'bg-green-500 h-5' : 'bg-red-500 h-2';
                const title = `ƒê·ªÅ xu·∫•t: ${p.predicted}, Ra: ${p.actual} -> ${isWin ? 'TH·∫ÆNG' : 'THUA'}`;
                individualBarsHTML += `<div class="flex-shrink-0 w-1 ${barClass} rounded-t-sm" title="${title}"></div>`;
            });
        } else {
             individualBarsHTML += `<div class="w-full text-center"><span class="text-gray-600 text-xs">Ch∆∞a c√≥</span></div>`;
        }
        individualBarsHTML += '</div>';

        return `
            <div class="grid gap-x-2 items-center bg-gray-700 bg-opacity-50 p-3 rounded-lg mt-2 text-sm" style="grid-template-columns: 2fr 4fr 2fr 2fr 3fr;">
                <span class="font-medium text-gray-300">${label}</span>
                ${individualBarsHTML}
                <span class="text-white font-semibold text-center">${data.total}</span>
                <span class="text-green-400 font-semibold text-center">${data.wins}</span>
                <span class="font-bold text-right ${rate >= 70 ? 'text-green-400' : (rate >= 50 ? 'text-yellow-400' : 'text-red-400')}">
                    ${rate > -1 ? rate.toFixed(1) + '%' : '-'}
                </span>
            </div>
        `;
    };

    html += createRowHTML('Theo H·ªá Th·ªëng', stats.follow);
    html += createRowHTML('Ng∆∞·ª£c H·ªá Th·ªëng', stats.against);

    tableDiv.innerHTML = html;
}

function updateSimulationUI() {
    if (!state.currentSessionId) return;
    const session = state.sessions[state.currentSessionId];
    const sim = session.simulation;

    if (!sim) return;

    document.getElementById('baseBet').value = sim.baseBet;
    document.getElementById('stopLossLevel').value = sim.stopLossLevel;
    document.getElementById('displayColumns').value = sim.displayColumns;
    document.getElementById('simModeFollow').checked = sim.mode === 'follow';
    document.getElementById('simModeAgainst').checked = sim.mode === 'against';

    const profitLossEl = document.getElementById('simProfitLoss');
    profitLossEl.textContent = sim.profitLoss.toLocaleString();
    profitLossEl.className = `font-bold text-lg ${sim.profitLoss > 0 ? 'text-green-400' : sim.profitLoss < 0 ? 'text-red-400' : 'text-white'}`;
    
    const simNextBetEl = document.getElementById('simNextBet');
    if (state.currentFinalPrediction?.prediction) {
        let betOn = state.currentFinalPrediction.prediction;
        if (sim.mode === 'against') {
            betOn = betOn === 'P' ? 'B' : 'P';
        }
        const betSideText = betOn === 'P' ? 'PLAYER' : 'BANKER';
        const betSideColor = betOn === 'P' ? 'text-blue-400' : 'text-red-400';
        simNextBetEl.innerHTML = `${sim.currentBet.toLocaleString()} <span class="font-semibold ${betSideColor}">(${betSideText})</span>`;
    } else {
        simNextBetEl.textContent = sim.currentBet.toLocaleString();
    }


    const logEl = document.getElementById('simLog');
    const displayColumns = parseInt(document.getElementById('displayColumns').value) || 6;
    logEl.style.gridTemplateColumns = `repeat(${displayColumns}, 1fr)`;
    if (sim.log.length === 0) {
        logEl.innerHTML = `<p class="text-gray-500 text-xs col-span-6 text-center" style="grid-column: span ${displayColumns}">Ch∆∞a c√≥...</p>`;
    } else {
        logEl.innerHTML = sim.log.map(entry => {
            const isWin = entry.startsWith('+');
            const amount = entry.substring(1);
            const bgColor = isWin ? 'bg-green-500' : 'bg-red-500';
            return `<span class="sim-log-item ${bgColor}">${isWin ? '+' : '-'}${parseInt(amount).toLocaleString()}</span>`;
        }).join('');
    }

    logEl.scrollTop = logEl.scrollHeight;
}


function updateAllUI() {
    updateBigRoadUI();
    updateAccuracyUI();
    updateGlobalAccuracyUI();
    updateAnalysisUI();
    updateConfidenceStatsUI();
    updateVerdictStatsUI();
    updateSimulationUI();
    updateChotAnalysisUI();
}

function toggleSessionManagement() {
    const content = document.getElementById('sessionManagementContent');
    const icon = document.getElementById('toggleSessionIcon');
    
    if (content.style.maxHeight && content.style.maxHeight !== '0px') {
        content.style.maxHeight = '0px';
        icon.style.transform = 'rotate(-180deg)';
    } else {
        content.style.maxHeight = content.scrollHeight + 'px';
        icon.style.transform = 'rotate(0deg)';
    }
}

// --- START: M√É M·ªöI CHO PH√ÇN T√çCH "CH·ªêT" ---

/**
 * Thu th·∫≠p t·∫•t c·∫£ c√°c chu·ªói W/L l·ªãch s·ª≠ t·ª´ 7 ngu·ªìn d·ªØ li·ªáu.
 */
function getChotAnalysisData() {
    const sequencesBySource = {
        follow: {}, against: {},
        '90-100': {}, '80-90': {}, '70-80': {}, '60-70': {}, '50-60': {}
    };
    // ƒê·ªãnh nghƒ©a 5 kho·∫£ng tin c·∫≠y
    const rangeDefs = [
        { key: '50-60', min: 50, max: 60 },
        { key: '60-70', min: 60, max: 70 },
        { key: '70-80', min: 70, max: 80 },
        { key: '80-90', min: 80, max: 90 },
        { key: '90-100', min: 90, max: 100.1 } // S·ª≠ d·ª•ng 100.1 ƒë·ªÉ bao g·ªìm c·∫£ 100
    ];

    for (const sessionId in state.sessions) {
        const session = state.sessions[sessionId];
        
        // 1. Chu·ªói Ph√°n Quy·∫øt (Verdict Sequences)
        let followSeq = '', againstSeq = '';
        (session.verdictPredictions || []).forEach(p => {
            const result = p.predicted === p.actual ? 'W' : 'L';
            if (p.verdict === 'follow') followSeq += result;
            else if (p.verdict === 'against') againstSeq += result;
        });
        sequencesBySource.follow[sessionId] = followSeq;
        sequencesBySource.against[sessionId] = againstSeq;

        // 2. Chu·ªói Tin C·∫≠y (Confidence Sequences)
        const sessionConfSequences = { '90-100': '', '80-90': '', '70-80': '', '60-70': '', '50-60': '' };
        (session.predictions || []).forEach(p => {
            const result = p.predicted === p.actual ? 'W' : 'L';
            // T√¨m kho·∫£ng tin c·∫≠y m√† ph√°n ƒëo√°n n√†y thu·ªôc v·ªÅ
            const foundRange = rangeDefs.find(r => p.confidence >= r.min && p.confidence < r.max);
            if (foundRange) {
                sessionConfSequences[foundRange.key] += result;
            }
        });

        // L∆∞u chu·ªói c·ªßa 5 kho·∫£ng tin c·∫≠y
        for (const key in sessionConfSequences) {
            sequencesBySource[key][sessionId] = sessionConfSequences[key];
        }
    }
    return sequencesBySource;
}

/**
 * T√¨m ki·∫øm m·ªôt pattern trong l·ªãch s·ª≠ v√† ƒë·∫øm k·∫øt qu·∫£ ti·∫øp theo (W/L).
 * @param {string} pattern - Chu·ªói m·∫´u ƒë·ªÉ t√¨m, v√≠ d·ª•: "WWLWL"
 * @param {Object} historicalSequences - ƒê·ªëi t∆∞·ª£ng ch·ª©a chu·ªói l·ªãch s·ª≠ c·ªßa c√°c phi√™n, v√≠ d·ª•: { "session-1": "WWLLW...", "session-2": "LWLW..." }
 * @returns {Object} - { W: (s·ªë l·∫ßn W), L: (s·ªë l·∫ßn L), total: (t·ªïng s·ªë) }
 */
function findNextOutcomeInHistory(pattern, historicalSequences) {
    // C·∫ßn √≠t nh·∫•t 3 k√Ω t·ª± ƒë·ªÉ t·∫°o th√†nh m·ªôt m·∫´u c√≥ √Ω nghƒ©a
    if (!pattern || pattern.length < 3) return { W: 0, L: 0, total: 0 }; 
    let W = 0, L = 0;
    
    for (const sessionId in historicalSequences) {
        const history = historicalSequences[sessionId];
        if (!history) continue;
        
        let i = -1;
        // T√¨m t·∫•t c·∫£ c√°c l·∫ßn xu·∫•t hi·ªán c·ªßa pattern trong l·ªãch s·ª≠ c·ªßa phi√™n n√†y
        while ((i = history.indexOf(pattern, i + 1)) !== -1) {
            const nextCharIndex = i + pattern.length;
            // ƒê·∫£m b·∫£o c√≥ k√Ω t·ª± ti·∫øp theo
            if (nextCharIndex < history.length) {
                if (history[nextCharIndex] === 'W') W++;
                else L++;
            }
        }
    }
    return { W, L, total: W + L };
}

/**
 * T·∫°o HTML cho m·ªôt h√†ng trong b·∫£ng ph√¢n t√≠ch "CH·ªêT".
 * Th√™m tham s·ªë isActive v√† finalPBprediction
 * THAY ƒê·ªîI: Th√™m currentSequence ƒë·ªÉ v·∫Ω bi·ªÉu ƒë·ªì c·ªôt l·ªãch s·ª≠ W/L
 */
function getChotRowHTML(name, pattern, stats, predictedWL = null, isActive = false, finalPBprediction = null, currentSequence = "") {
    let wRate = 0, lRate = 0;
    if (stats.total > 0) {
        wRate = (stats.W / stats.total) * 100;
        lRate = (stats.L / stats.total) * 100;
    }

    let wlPredictionText = '-';
    let wlPredictionColor = 'text-gray-500';
    
    if (predictedWL) {
        // C√≥ ƒë·ªÅ xu·∫•t
        wlPredictionText = `-> ${predictedWL} (${Math.max(wRate, lRate).toFixed(0)}%)`;
        wlPredictionColor = predictedWL === 'W' ? 'text-green-400' : 'text-red-400';
    } else if (stats.total >= 2 && wRate === lRate) { // Ch·ªâ hi·ªÉn th·ªã C√¢n b·∫±ng n·∫øu c√≥ √≠t nh·∫•t 2 m·∫´u l·ªãch s·ª≠
         wlPredictionText = 'C√¢n b·∫±ng';
         wlPredictionColor = 'text-yellow-400';
    } else if (stats.total > 0 && stats.total < 2) { // Hi·ªÉn th·ªã '√çt m·∫´u' n·∫øu ch·ªâ c√≥ 1
         wlPredictionText = '√çt m·∫´u';
         wlPredictionColor = 'text-gray-500';
    }
    // else: kh√¥ng c√≥ d·ªØ li·ªáu (total = 0), gi·ªØ nguy√™n l√† '-'

    // Hi·ªÉn th·ªã P/B cu·ªëi c√πng n·∫øu ngu·ªìn n√†y ho·∫°t ƒë·ªông v√† c√≥ d·ª± ƒëo√°n W/L
    let pbIndicator = '';
    if (isActive && finalPBprediction) {
        const pbColor = finalPBprediction === 'P' ? 'text-blue-400' : 'text-red-400';
        pbIndicator = `<span class="font-bold ${pbColor} ml-2">[${finalPBprediction}]</span>`;
    }

    const activeClass = isActive ? 'bg-gray-700 bg-opacity-60 ring-1 ring-purple-500' : 'bg-gray-900'; // Highlight h√†ng ho·∫°t ƒë·ªông

    // --- M·ªöI: BI·ªÇU ƒê·ªí C·ªòT L·ªäCH S·ª¨ W/L (gi·ªëng nh∆∞ Confidence Stats) ---
    const displayedHistory = currentSequence.slice(-30); // L·∫•y t·ªëi ƒëa 30 k·∫øt qu·∫£ W/L g·∫ßn nh·∫•t
    let individualBarsHTML = `<div class="flex items-end justify-center gap-px h-5 my-auto overflow-hidden" title="Di·ªÖn bi·∫øn W/L g·∫ßn ƒë√¢y (T·ªëi ƒëa 30)">`;
    if (displayedHistory.length > 0) {
        for (const result of displayedHistory) {
            const isWin = result === 'W';
            const barClass = isWin ? 'bg-green-500 h-5' : 'bg-red-500 h-2';
            const title = `K·∫øt qu·∫£: ${isWin ? 'TH·∫ÆNG' : 'THUA'}`;
            individualBarsHTML += `<div class="flex-shrink-0 w-1 ${barClass} rounded-t-sm" title="${title}"></div>`;
        }
    } else {
        individualBarsHTML += `<div class="w-full text-center"><span class="text-gray-600 text-xs">Ch∆∞a c√≥</span></div>`;
    }
    individualBarsHTML += '</div>';
    // --- K·∫æT TH√öC BI·ªÇU ƒê·ªí C·ªòT L·ªäCH S·ª¨ W/L ---

    return `
        <div class="grid grid-cols-12 gap-2 items-center text-sm mb-1 p-2 ${activeClass} rounded-lg transition-colors duration-300">
            <div class="col-span-2 font-semibold ${isActive ? 'text-purple-300' : 'text-gray-300'}">${name}</div>
            <div class="col-span-3 text-gray-400 text-xs truncate" title="M·∫´u W/L: ...${pattern}">${pattern.length > 10 ? '...' : ''}${pattern.slice(-10)}</div>
            
            <!-- THAY TH·∫æ: Bi·ªÉu ƒë·ªì c·ªôt l·ªãch s·ª≠ W/L -->
            <div class="col-span-4">
                ${individualBarsHTML}
            </div>
            
            <div class="col-span-3 text-right font-bold ${wlPredictionColor}">
                ${wlPredictionText}
                ${pbIndicator} {/* Th√™m ch·ªâ b√°o P/B */}
            </div>
        </div>
    `;
}


/**
 * C·∫≠p nh·∫≠t to√†n b·ªô giao di·ªán cho b·∫£ng ph√¢n t√≠ch "CH·ªêT" - Logic m·ªõi.
 */
function updateChotAnalysisUI() {
    const PATTERN_LENGTH = 5;
    const MIN_OCCURRENCES_FOR_PREDICTION = 2; // C·∫ßn √≠t nh·∫•t 2 l·∫ßn xu·∫•t hi·ªán trong l·ªãch s·ª≠ ƒë·ªÉ d·ª± ƒëo√°n W/L
    // Kh√¥ng c√≤n MIN_CONFIDENCE v√¨ ch√∫ng ta b·ªè phi·∫øu P/B tr·ª±c ti·∫øp

    const analysisDetailsDiv = document.getElementById('chotAnalysisDetails');
    const finalChotResultDiv = document.getElementById('finalChotResult');
    if (!analysisDetailsDiv || !finalChotResultDiv) return;

    // --- B∆∞·ªõc 1: X√°c ƒë·ªãnh ngu·ªìn ho·∫°t ƒë·ªông v√† P/B g·ªëc ---
    const activeSourcesKeys = new Set();
    const originalSystemPB = state.originalSystemPrediction; // P/B g·ªëc t·ª´ h·ªá th·ªëng ch√≠nh
    const currentConfidence = state.currentPrediction?.confidence;
    const finalVerdictInfo = state.currentFinalPrediction; // Ch·ª©a { verdict: '...', prediction: 'P'/'B' }

    if (!originalSystemPB || finalVerdictInfo === null) { // Ch∆∞a c√≥ ƒë·ªß d·ªØ li·ªáu t·ª´ h·ªá th·ªëng ch√≠nh
        analysisDetailsDiv.innerHTML = '<p class="text-gray-500 text-center py-4">Ch∆∞a c√≥ ƒë·ªß d·ªØ li·ªáu t·ª´ h·ªá th·ªëng ch√≠nh ƒë·ªÉ ch·∫°y Ch·ªët...</p>';
        finalChotResultDiv.innerHTML = `
            <p class="text-lg text-gray-400 mb-2">ƒê·ªÅ xu·∫•t "CH·ªêT":</p>
            <p class="text-3xl font-extrabold text-gray-400">... Ch·ªù t√≠n hi·ªáu ...</p>`;
        finalChotResultDiv.className = `text-center bg-gray-900 py-6 rounded-lg border-2 border-purple-500 mb-4 transition-all duration-300`;
        return;
    }

    // X√°c ƒë·ªãnh ngu·ªìn verdict ho·∫°t ƒë·ªông (Theo/Ng∆∞·ª£c)
    if (finalVerdictInfo.verdict === 'follow') {
        activeSourcesKeys.add('follow');
    } else if (finalVerdictInfo.verdict === 'against') {
        activeSourcesKeys.add('against');
    }
    // N·∫øu verdict l√† neutral ho·∫∑c certain, kh√¥ng c√≥ ngu·ªìn Theo/Ng∆∞·ª£c n√†o ho·∫°t ƒë·ªông cho CH·ªêT

    // X√°c ƒë·ªãnh ngu·ªìn confidence range ho·∫°t ƒë·ªông
    const rangeDefs = [
        { key: '50-60', min: 50, max: 60 }, { key: '60-70', min: 60, max: 70 },
        { key: '70-80', min: 70, max: 80 }, { key: '80-90', min: 80, max: 90 },
        { key: '90-100', min: 90, max: 100.1 }
    ];
    const activeConfidenceRange = rangeDefs.find(r => currentConfidence >= r.min && currentConfidence < r.max);
    if (activeConfidenceRange) {
        activeSourcesKeys.add(activeConfidenceRange.key);
    }
    // --- K·∫øt th√∫c B∆∞·ªõc 1 ---

    const allSequences = getChotAnalysisData();
    const currentSessionId = state.currentSessionId;
    if (!currentSessionId) return;

    const sources = [
        { key: 'follow', name: 'Theo HT' }, { key: 'against', name: 'Ng∆∞·ª£c HT' },
        { key: '90-100', name: '90-100%' }, { key: '80-90', name: '80-90%' },
        { key: '70-80', name: '70-80%' }, { key: '60-70', name: '60-70%' },
        { key: '50-60', name: '50-60%' }
    ];

    let analysisRowsHTML = '';
    const finalVotesPB = { P: 0, B: 0 }; // Phi·∫øu b·∫ßu Player/Banker

    // --- B∆∞·ªõc 2, 3, 4, 5: Ph√¢n t√≠ch t·ª´ng ngu·ªìn ---
    for (const source of sources) {
        const isActive = activeSourcesKeys.has(source.key); // Ki·ªÉm tra ngu·ªìn c√≥ ho·∫°t ƒë·ªông kh√¥ng
        const currentSequence = allSequences[source.key][currentSessionId] || "";
        let predictedWL = null;
        let finalPBprediction = null;
        let stats = { W: 0, L: 0, total: 0 }; // M·∫∑c ƒë·ªãnh l√† kh√¥ng c√≥ d·ªØ li·ªáu

        if (currentSequence.length >= PATTERN_LENGTH) {
            const pattern = currentSequence.slice(-PATTERN_LENGTH);
            const historicalData = { ...allSequences[source.key] };
            delete historicalData[currentSessionId];
            stats = findNextOutcomeInHistory(pattern, historicalData); // L·∫•y th·ªëng k√™ W/L l·ªãch s·ª≠

            // D·ª± ƒëo√°n W/L n·∫øu ƒë·ªß m·∫´u v√† kh√¥ng c√¢n b·∫±ng
            if (stats.total >= MIN_OCCURRENCES_FOR_PREDICTION && stats.W !== stats.L) {
                predictedWL = stats.W > stats.L ? 'W' : 'L';

                // Ch·ªâ suy ra P/B v√† b·ªè phi·∫øu n·∫øu ngu·ªìn n√†y ƒëang ho·∫°t ƒë·ªông
                if (isActive) {
                    if (predictedWL === 'W') {
                        finalPBprediction = originalSystemPB; // Gi·ªëng P/B g·ªëc
                    } else { // predictedWL === 'L'
                        finalPBprediction = originalSystemPB === 'P' ? 'B' : 'P'; // Ng∆∞·ª£c P/B g·ªëc
                    }
                    // B·ªè phi·∫øu
                    if (finalPBprediction) {
                       finalVotesPB[finalPBprediction]++;
                    }
                }
            }
             // THAY ƒê·ªîI: Truy·ªÅn th√™m currentSequence v√†o h√†m
             analysisRowsHTML += getChotRowHTML(source.name, pattern, stats, predictedWL, isActive, finalPBprediction, currentSequence);
        } else {
            // Kh√¥ng ƒë·ªß W/L pattern hi·ªán t·∫°i
            // THAY ƒê·ªîI: Truy·ªÅn th√™m currentSequence v√†o h√†m
            analysisRowsHTML += getChotRowHTML(source.name, "Ch·ªù th√™m W/L...", stats, null, isActive, null, currentSequence);
        }
    }
    // --- K·∫øt th√∫c B∆∞·ªõc 2-5 ---

    analysisDetailsDiv.innerHTML = analysisRowsHTML;

    // --- B∆∞·ªõc 6, 7: T·ªïng h·ª£p v√† hi·ªÉn th·ªã k·∫øt qu·∫£ CH·ªêT ---
    let finalChotPredictionText = '... Ch·ªù t√≠n hi·ªáu ...';
    let finalChotPredictionColor = 'text-gray-400';
    let finalChotBorderColor = 'border-purple-500';
    let finalChotPB = null; // P/B cu·ªëi c√πng

    const totalVotes = finalVotesPB.P + finalVotesPB.B;

    if (totalVotes > 0) { // Ch·ªâ ƒë∆∞a ra k·∫øt lu·∫≠n n·∫øu c√≥ √≠t nh·∫•t 1 phi·∫øu b·∫ßu
         if (finalVotesPB.P > finalVotesPB.B) {
            finalChotPB = 'P';
            finalChotPredictionText = `PLAYER ( ${finalVotesPB.P} / ${totalVotes} phi·∫øu )`;
            finalChotPredictionColor = 'text-blue-400';
            finalChotBorderColor = 'border-blue-500';
         } else if (finalVotesPB.B > finalVotesPB.P) {
            finalChotPB = 'B';
            finalChotPredictionText = `BANKER ( ${finalVotesPB.B} / ${totalVotes} phi·∫øu )`;
            finalChotPredictionColor = 'text-red-400';
            finalChotBorderColor = 'border-red-500';
         } else {
            // Tr∆∞·ªùng h·ª£p P == B
            finalChotPredictionText = `H√íA PHI·∫æU (${finalVotesPB.P} - ${finalVotesPB.B})`;
            finalChotPredictionColor = 'text-yellow-400';
            finalChotBorderColor = 'border-yellow-500';
         }
    } else {
         // Kh√¥ng c√≥ ngu·ªìn n√†o ho·∫°t ƒë·ªông ƒë·ªß ƒëi·ªÅu ki·ªán b·ªè phi·∫øu
         finalChotPredictionText = 'Kh√¥ng ƒë·ªß t√≠n hi·ªáu b·ªè phi·∫øu';
    }
    
    finalChotResultDiv.className = `text-center bg-gray-900 py-6 rounded-lg border-2 ${finalChotBorderColor} mb-4 transition-all duration-300`;
    finalChotResultDiv.innerHTML = `
        <p class="text-lg text-gray-400 mb-2">ƒê·ªÅ xu·∫•t "CH·ªêT":</p>
        <p class="text-3xl font-extrabold ${finalChotPredictionColor}">${finalChotPredictionText}</p>
    `;
    // --- K·∫øt th√∫c B∆∞·ªõc 6, 7 ---
}

// --- END: M√É M·ªöI CHO PH√ÇN T√çCH "CH·ªêT" ---


function updateSimSetting(key, value, silent = false) {
    if (!state.currentSessionId) return false;
    const session = state.sessions[state.currentSessionId];
    if (!session || !session.simulation) return false;

    let isValid = true;
    let validatedValue = value;
    let inputId = '';

    switch(key) {
        case 'baseBet': inputId = 'baseBet'; break;
        case 'stopLossLevel': inputId = 'stopLossLevel'; break;
        case 'displayColumns': inputId = 'displayColumns'; break;
    }

    if (key !== 'mode') {
        const numValue = parseInt(value);
        if (isNaN(numValue)) {
            isValid = false;
        } else {
            if ((key === 'baseBet' || key === 'stopLossLevel') && numValue <= 0) {
                if (!silent) showToast(`${key === 'baseBet' ? 'M·ª©c c∆∞·ª£c c∆° b·∫£n' : 'Ng∆∞·ª°ng c·∫Øt l·ªó'} ph·∫£i l·ªõn h∆°n 0.`, 'warning');
                isValid = false;
            }
            if (key === 'displayColumns' && (numValue < 2 || numValue > 9)) {
                if (!silent) showToast('S·ªë c·ªôt hi·ªÉn th·ªã ph·∫£i l√† m·ªôt s·ªë t·ª´ 2 ƒë·∫øn 9.', 'warning');
                isValid = false;
            }
            validatedValue = numValue;
        }
    }

    if (isValid) {
        session.simulation[key] = validatedValue;
        if (key === 'baseBet' && session.simulation.consecutiveLosses === 0) {
            session.simulation.currentBet = session.simulation.baseBet;
        }
        saveSessions();
        updateSimulationUI();
    } else {
        if(inputId) document.getElementById(inputId).value = session.simulation[key];
    }
    return isValid;
}


// --- EVENT HANDLERS & ACTIONS ---
function addResult(result) {
    if (!state.currentSessionId) return;
    const session = state.sessions[state.currentSessionId];
    
    if(state.currentFinalPrediction?.prediction) {
        const sim = session.simulation;
        let betOn = state.currentFinalPrediction.prediction;
        if (sim.mode === 'against') {
            betOn = betOn === 'P' ? 'B' : 'P';
        }

        const currentBetAmount = sim.currentBet;
        const isWin = betOn === result;

        if (isWin) {
            sim.profitLoss += currentBetAmount;
            sim.log.push(`+${currentBetAmount}`);
            sim.currentBet = sim.baseBet;
            sim.consecutiveLosses = 0;
        } else {
            sim.profitLoss -= currentBetAmount;
            sim.log.push(`-${currentBetAmount}`);
            sim.consecutiveLosses++;

            if (sim.consecutiveLosses >= sim.stopLossLevel) {
                sim.currentBet = sim.baseBet;
                sim.consecutiveLosses = 0;
                showToast(`ƒê√£ ƒë·∫°t ng∆∞·ª°ng c·∫Øt l·ªó! Quay v·ªÅ m·ª©c c∆∞·ª£c ban ƒë·∫ßu.`, 'warning');
            } else {
                sim.currentBet = currentBetAmount * 2;
            }
        }
    }

    if (state.currentPrediction && state.currentPrediction.prediction) {
        session.predictions.push({ predicted: state.currentPrediction.prediction, actual: result, confidence: state.currentPrediction.confidence });
    }
    
    if (!session.verdictPredictions) session.verdictPredictions = [];
    if (state.currentFinalPrediction && state.currentFinalPrediction.prediction) {
        session.verdictPredictions.push({
            verdict: state.currentFinalPrediction.verdict,
            predicted: state.currentFinalPrediction.prediction,
            actual: result
        });
    }

    session.history.push(result);
    
    // C·∫≠p nh·∫≠t state.sessions[state.currentSessionId] *tr∆∞·ªõc khi* g·ªçi h√†m ti·∫øp theo
    // (M·∫∑c d√π trong JS, c√°c ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c truy·ªÅn b·∫±ng tham chi·∫øu, n√™n ƒëi·ªÅu n√†y l√† an to√†n)
    
    const newOptimalLength = updateLengthPerformanceAndFindOptimal([...session.history].slice(0, -1), Object.values(state.sessions), result);
    session.optimalLength = newOptimalLength;

    state.currentPrediction = null; 
    state.originalSystemPrediction = null; // X√≥a P/B g·ªëc
    state.currentFinalPrediction = null;
    saveSessions();
    updateAllUI();
}
function updateLengthPerformanceAndFindOptimal(history, allSessions, newResult) {
    const session = state.sessions[state.currentSessionId];
    if (!session) return null; // Th√™m ki·ªÉm tra an to√†n
    if (!session.lengthPerformance) session.lengthPerformance = {};
    const candidates = [];
    for (let len = 10; len <= 20; len++) {
        if (history.length < len) continue;
        const pattern = history.slice(-len);
        const { prediction } = state.matcher.getPredictionForPattern(pattern, allSessions);
        if (prediction) {
            if (!session.lengthPerformance[len]) session.lengthPerformance[len] = { wins: 0, total: 0 };
            const stats = session.lengthPerformance[len];
            stats.total++;
            if (prediction === newResult) stats.wins++;
            // S·ª¨A L·ªñI: Lu√¥n th√™m v√†o candidates n·∫øu c√≥ d·ªØ li·ªáu, kh√¥ng ch·ªâ khi th·∫Øng
            candidates.push({ length: len, rate: stats.wins / stats.total, total: stats.total });
        }
    }
    if (candidates.length === 0) return session.optimalLength; // Gi·ªØ nguy√™n optimalLength c≈© n·∫øu kh√¥ng c√≥ candidate
    candidates.sort((a, b) => b.rate !== a.rate ? b.rate - a.rate : b.total - a.total);
    return candidates[0].length;
}
function undoLast() {
    if (!state.currentSessionId || state.sessions[state.currentSessionId].history.length === 0) return;
    
    const session = state.sessions[state.currentSessionId];
    
    // S·ª¨A L·ªñI LOGIC HO√ÄN T√ÅC
    if (session.simulation.log.length > 0) {
        const sim = session.simulation;
        const lastLogEntry = sim.log.pop();
        const lastAmount = parseInt(lastLogEntry); // ƒê√¢y l√† s·ªë ti·ªÅn th·∫Øng/thua (vd: +10, -20)
        
        sim.profitLoss -= lastAmount; // Ho√†n t√°c l√£i/l·ªó

        // Logic m·ªõi: M·ª©c c∆∞·ª£c c·ªßa v√°n v·ª´a ho√†n t√°c ch√≠nh l√† gi√° tr·ªã tuy·ªát ƒë·ªëi c·ªßa log entry ƒë√≥.
        // Tr·ª´ khi ƒë√≥ l√† v√°n th·∫Øng (quay v·ªÅ baseBet), th√¨ v√°n *tr∆∞·ªõc ƒë√≥* m·ªõi l√† v√°n thua.
        
        // T√≠nh to√°n l·∫°i chu·ªói thua t·ª´ log ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t
        let newConsecutiveLosses = 0;
        for (let i = sim.log.length - 1; i >= 0; i--) {
            if (sim.log[i].startsWith('-')) {
                newConsecutiveLosses++;
            } else {
                break; // D·ª´ng l·∫°i khi g·∫∑p v√°n th·∫Øng
            }
        }
        sim.consecutiveLosses = newConsecutiveLosses;

        // T√≠nh to√°n l·∫°i m·ª©c c∆∞·ª£c ti·∫øp theo
        if (newConsecutiveLosses === 0) {
            sim.currentBet = sim.baseBet; // N·∫øu kh√¥ng c√≥ chu·ªói thua, quay v·ªÅ c∆∞·ª£c g·ªëc
        } else if (newConsecutiveLosses >= sim.stopLossLevel) {
            sim.currentBet = sim.baseBet; // N·∫øu chu·ªói thua tr∆∞·ªõc ƒë√≥ ƒë·∫°t ng∆∞·ª°ng, v√°n n√†y (sau khi ho√†n t√°c) ƒë√°ng l·∫Ω ƒë√£ reset
        } else {
             // N·∫øu ƒëang trong chu·ªói thua, t√≠nh to√°n l·∫°i m·ª©c c∆∞·ª£c
             // M·ª©c c∆∞·ª£c c·ªßa v√°n v·ª´a b·ªã x√≥a l√† v√°n thua cu·ªëi c√πng
             // M·ª©c c∆∞·ª£c *ti·∫øp theo* (hi·ªÉn th·ªã tr√™n UI) ph·∫£i l√† 2 * v√°n thua ƒë√≥
             
             // T√¨m v√°n c∆∞·ª£c (thua) cu·ªëi c√πng
             let lastBetAmount = sim.baseBet;
             let tempLosses = 0;
             for (let i = 0; i < sim.log.length; i++) {
                 const entry = sim.log[i];
                 if(entry.startsWith('+')) {
                     lastBetAmount = sim.baseBet;
                     tempLosses = 0;
                 } else {
                     lastBetAmount = Math.abs(parseInt(entry));
                     tempLosses++;
                     if(tempLosses >= sim.stopLossLevel) {
                         lastBetAmount = sim.baseBet;
                         tempLosses = 0;
                     }
                 }
             }

             if (sim.log.length === 0) {
                sim.currentBet = sim.baseBet;
             } else if (sim.log[sim.log.length - 1].startsWith('+')) {
                 sim.currentBet = sim.baseBet; // V√°n cu·ªëi l√† th·∫Øng, v√°n ti·∫øp c∆∞·ª£c g·ªëc
             } else {
                 // V√°n cu·ªëi l√† thua
                 if (sim.consecutiveLosses >= sim.stopLossLevel) {
                     sim.currentBet = sim.baseBet; // ƒê·∫°t ng∆∞·ª°ng, reset
                 } else {
                     sim.currentBet = Math.abs(parseInt(sim.log[sim.log.length - 1])) * 2; // G·∫•p ƒë√¥i v√°n thua cu·ªëi
                 }
             }
        }
    }


    const lastResult = session.history[session.history.length - 1];
    const historyForUndo = session.history.slice(0, -1);
    
    const tempSessions = JSON.parse(JSON.stringify(state.sessions));
    tempSessions[state.currentSessionId].history.pop();
    const allSessionsForContext = Object.values(tempSessions);

    if (session.lengthPerformance) {
        for (let len = 10; len <= 20; len++) {
            if (historyForUndo.length < len) continue;
            
            const pattern = historyForUndo.slice(-len);
            const { prediction } = state.matcher.getPredictionForPattern(pattern, allSessionsForContext);

            if (prediction) {
                const stats = session.lengthPerformance[len];
                if (stats && stats.total > 0) {
                    stats.total--;
                    if (prediction === lastResult && stats.wins > 0) {
                        stats.wins--;
                    }
                }
            }
        }
    }

    const candidates = [];
    if (session.lengthPerformance) {
        for (const len in session.lengthPerformance) {
            const stats = session.lengthPerformance[len];
            if (stats.total > 0) {
                candidates.push({
                    length: parseInt(len, 10),
                    rate: stats.wins / stats.total,
                    total: stats.total
                });
            }
        }
    }

    if (candidates.length > 0) {
        candidates.sort((a, b) => b.rate !== a.rate ? b.rate - a.rate : b.total - a.total);
        session.optimalLength = candidates[0].length;
    } else {
        session.optimalLength = null;
    }

    session.history.pop();
    if (session.predictions.length > 0) {
        session.predictions.pop();
    }
    if (session.verdictPredictions && session.verdictPredictions.length > 0) {
        session.verdictPredictions.pop();
    }

    saveSessions();
    updateAllUI();
}
function clearCurrentSessionHistory() {
    if (!state.currentSessionId) return;
    const session = state.sessions[state.currentSessionId];
    session.history = []; 
    session.predictions = [];
    session.verdictPredictions = [];
    session.lengthPerformance = {}; 
    session.optimalLength = null;

    const sim = session.simulation;
    sim.profitLoss = 0;
    sim.currentBet = sim.baseBet;
    sim.log = [];
    sim.consecutiveLosses = 0;

    saveSessions();
    updateAllUI();
}

// --- SESSION MANAGEMENT ---
function getSessions() { try { return JSON.parse(localStorage.getItem('baccaratPatternSessions_v11_sim')) || {}; } catch (e) { return {}; }}
function saveSessions() { localStorage.setItem('baccaratPatternSessions_v11_sim', JSON.stringify(state.sessions)); localStorage.setItem('lastActiveSession_v11_sim', state.currentSessionId); }
function renameSession() {
    if (!state.currentSessionId) return;
    const currentName = state.sessions[state.currentSessionId].name;
    showCustomPrompt("Nh·∫≠p t√™n m·ªõi cho phi√™n:", currentName, (newName) => {
        if (newName && newName.trim() !== "") {
            state.sessions[state.currentSessionId].name = newName.trim();
            saveSessions();
            updateSessionSelector();
        }
    });
}
function updateSessionSelector() {
    const selector = document.getElementById('sessionSelector');
    selector.innerHTML = '';
    const sortedKeys = Object.keys(state.sessions).sort((a, b) => {
        const timeA = parseInt(a.split('-')[1] || 0);
        const timeB = parseInt(b.split('-')[1] || 0);
        return timeA - timeB; // S·∫Øp x·∫øp t·ª´ c≈© ƒë·∫øn m·ªõi (ƒë·ªÉ khi load, c√°i m·ªõi nh·∫•t ·ªü d∆∞·ªõi)
    });
    
    // ƒê·∫£o ng∆∞·ª£c l·∫°i ƒë·ªÉ hi·ªÉn th·ªã c√°i m·ªõi nh·∫•t l√™n tr√™n
    sortedKeys.reverse().forEach(sessionId => {
        const option = document.createElement('option');
        option.value = sessionId;
        option.textContent = `${state.sessions[sessionId].name} (${state.sessions[sessionId].history.length} v√°n)`;
        if (sessionId === state.currentSessionId) {
            option.selected = true;
        }
        selector.appendChild(option);
    });

    selector.onclick = () => {
        if(selector.selectedOptions.length === 1) {
            if(selector.value !== state.currentSessionId) { // Ch·ªâ load n·∫øu ch·ªçn phi√™n kh√°c
                loadSession(selector.value);
            }
        }
    };
}
function createNewSession() {
    const newId = `session-${Date.now()}`;
    state.currentSessionId = newId;
    const defaultSimulation = {
        isActive: true, mode: 'follow', baseBet: 10,
        currentBet: 10, profitLoss: 0, log: [],
        stopLossLevel: 4, consecutiveLosses: 0, displayColumns: 6
    };
    state.sessions[newId] = { 
        name: `Phi√™n ${new Date().toLocaleString('vi-VN')}`, 
        history: [], predictions: [], verdictPredictions: [], 
        lengthPerformance: {}, optimalLength: null,
        simulation: defaultSimulation
    };
    saveSessions();
    updateSessionSelector();
    updateAllUI();
}
function deleteSelectedSessions() {
    const selector = document.getElementById('sessionSelector');
    const selectedIds = Array.from(selector.selectedOptions).map(opt => opt.value);

    if (selectedIds.length === 0) {
        showToast('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt phi√™n ƒë·ªÉ x√≥a.', 'warning');
        return;
    }

    if (selectedIds.length === Object.keys(state.sessions).length && Object.keys(state.sessions).length > 0) {
        showToast('Kh√¥ng th·ªÉ x√≥a t·∫•t c·∫£ c√°c phi√™n. H√£y d√πng n√∫t "X√≥a T·∫•t C·∫£".', 'error');
        return;
    }

    showCustomConfirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ${selectedIds.length} phi√™n ƒë√£ ch·ªçn kh√¥ng?`, () => {
        let wasCurrentSessionDeleted = false;
        selectedIds.forEach(id => {
            if (id === state.currentSessionId) {
                wasCurrentSessionDeleted = true;
            }
            delete state.sessions[id];
        });

        if (wasCurrentSessionDeleted) {
            state.currentSessionId = null;
            localStorage.removeItem('lastActiveSession_v11_sim');
        }
        
        saveSessions();
        initializeApp(); // Kh·ªüi t·∫°o l·∫°i ƒë·ªÉ ch·ªçn phi√™n m·ªõi (ho·∫∑c t·∫°o m·ªõi)
        showToast(`ƒê√£ x√≥a ${selectedIds.length} phi√™n.`, 'success');
    });
}

function deleteAllSessions() {
     showCustomConfirm('B·∫†N C√ì CH·∫ÆC MU·ªêN X√ìA T·∫§T C·∫¢ C√ÅC PHI√äN KH√îNG? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.', () => {
        state.sessions = {};
        state.currentSessionId = null;
        localStorage.removeItem('baccaratPatternSessions_v11_sim');
        localStorage.removeItem('lastActiveSession_v11_sim');
        initializeApp();
        showToast('T·∫•t c·∫£ c√°c phi√™n ƒë√£ ƒë∆∞·ª£c x√≥a.', 'success');
    });
}

function loadSession(sessionId) {
    if (state.sessions[sessionId]) { // Cho ph√©p load l·∫°i ch√≠nh phi√™n hi·ªán t·∫°i (ƒë·ªÉ refresh)
        state.currentSessionId = sessionId;
        state.currentPrediction = null;
        state.originalSystemPrediction = null;
        state.currentFinalPrediction = null;
        localStorage.setItem('lastActiveSession_v11_sim', state.currentSessionId);
        updateSessionSelector();
        updateAllUI();
    }
}

// --- IMPORT / EXPORT & RECALCULATION ---
function runSimulation(importedSessions) {
    // 1. Clear current state completely
    state.sessions = {};
    state.currentSessionId = null;
    localStorage.removeItem('baccaratPatternSessions_v11_sim');
    localStorage.removeItem('lastActiveSession_v11_sim');

    // 2. Sort imported sessions chronologically based on ID (timestamp)
    const sortedSessionIds = Object.keys(importedSessions).sort((a, b) => {
        const timeA = parseInt(a.split('-')[1] || 0);
        const timeB = parseInt(b.split('-')[1] || 0);
        return timeA - timeB;
    });

    // 3. Iterate through sorted sessions and simulate step-by-step
    sortedSessionIds.forEach((sessionId, index) => {
        const importedSession = importedSessions[sessionId];
        if (!importedSession || !importedSession.history) {
            console.warn(`Skipping invalid imported session: ${sessionId}`);
            return; // Skip if session data or history is missing
        }

        // 3a. Create a new empty session with imported settings
        const newId = sessionId; // Use the original ID
        state.currentSessionId = newId;
        const defaultSimulation = {
            isActive: true, mode: 'follow', baseBet: 10,
            currentBet: 10, profitLoss: 0, log: [],
            stopLossLevel: 4, consecutiveLosses: 0, displayColumns: 6
        };
        state.sessions[newId] = {
            name: importedSession.name || `Phi√™n nh·∫≠p ${index + 1}`,
            history: [], predictions: [], verdictPredictions: [],
            lengthPerformance: {}, optimalLength: null,
            simulation: JSON.parse(JSON.stringify(defaultSimulation)) // Start with default simulation
        };

        // Apply imported simulation settings (if they exist) before starting simulation
        if (importedSession.simulation) {
            // Only apply baseBet, stopLossLevel, and mode. Reset others.
            state.sessions[newId].simulation.baseBet = parseInt(importedSession.simulation.baseBet) || 10;
            state.sessions[newId].simulation.stopLossLevel = parseInt(importedSession.simulation.stopLossLevel) || 4;
            state.sessions[newId].simulation.mode = importedSession.simulation.mode === 'against' ? 'against' : 'follow'; // Default to 'follow'
             // Ensure currentBet starts at baseBet
            state.sessions[newId].simulation.currentBet = state.sessions[newId].simulation.baseBet;
        }


        // 3b. Simulate each result (P/B) by calling addResult
        importedSession.history.forEach((result, resultIndex) => {
            // IMPORTANT: Temporarily set the current session ID for addResult context
             // Make sure state reflects the session being processed *before* calling addResult
            state.currentSessionId = newId;
            // Validate result before adding
            if (result === 'P' || result === 'B') {
                 // Call addResult to process this single game result
                 // addResult handles predictions, simulation updates, etc.
                 // It relies on state.currentSessionId being set correctly
                addResult(result); // addResult will save state internally
            } else {
                console.warn(`Skipping invalid result '${result}' at index ${resultIndex} in session ${sessionId}`);
            }
        });

        // Save session state after fully processing one session
        saveSessions();

    });

    // 4. Load the very last session processed into the UI
    if (sortedSessionIds.length > 0) {
        const lastSessionId = sortedSessionIds[sortedSessionIds.length - 1];
        if (state.sessions[lastSessionId]) {
             loadSession(lastSessionId); // Load the final state of the last session
        } else if (Object.keys(state.sessions).length > 0) {
            // Fallback: load the last available session if the intended last one failed
            const availableKeys = Object.keys(state.sessions).sort((a, b) => parseInt(a.split('-')[1] || 0) - parseInt(b.split('-')[1] || 0));
            loadSession(availableKeys[availableKeys.length - 1]);
        } else {
            // If absolutely no sessions were successfully processed, create a new one
            createNewSession();
        }
    } else {
        // If the imported file was empty or invalid, create a new session
        createNewSession();
    }

     // 5. Final UI Update after all processing is done
     updateSessionSelector(); // C·∫≠p nh·∫≠t l·∫°i danh s√°ch session
     updateAllUI(); // Refresh UI once after the entire simulation loop
}


function importData(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const importedSessions = JSON.parse(e.target.result);
            if (typeof importedSessions !== 'object' || importedSessions === null) throw new Error("Invalid format");
            let dataOk = true;
            for(const key in importedSessions) {
                 const s = importedSessions[key];
                 // Cho ph√©p history r·ªóng, nh∆∞ng ph·∫£i l√† array
                 if(!s.name || !Array.isArray(s.history)) {
                     dataOk = false;
                     break;
                 };
            }
            if(!dataOk && Object.keys(importedSessions).length > 0) { // Ch·ªâ b√°o l·ªói n·∫øu file kh√¥ng r·ªóng
                 throw new Error("Invalid session data");
            }
            
            showCustomConfirm('D·ªØ li·ªáu hi·ªán t·∫°i s·∫Ω b·ªã ghi ƒë√®. B·∫°n c√≥ ch·∫Øc mu·ªën ti·∫øp t·ª•c?', () => {
                showLoadingModal('ƒêang t√≠nh to√°n l·∫°i to√†n b·ªô l·ªãch s·ª≠ v√† m√¥ ph·ªèng c∆∞·ª£c...');

                setTimeout(() => {
                    runSimulation(importedSessions);
                    // saveSessions(); // runSimulation now saves after each session
                    hideLoadingModal();
                    showToast('Nh·∫≠p v√† m√¥ ph·ªèng l·∫°i th√†nh c√¥ng!', 'success');
                }, 100);
            });
        } catch (error) {
            showToast('L·ªói: File d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.', 'error');
            console.error("Import error:", error);
        } finally {
            event.target.value = '';
        }
    };
    reader.readAsText(file);
}

function exportData() {
    if (!state.sessions || Object.keys(state.sessions).length === 0) {
        showToast('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t.', 'warning');
        return;
    }
    const dataToExport = JSON.stringify(state.sessions, null, 2);
    const blob = new Blob([dataToExport], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
    a.download = `BaccaratAnalysis_AllSessions_${timestamp}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('D·ªØ li·ªáu c·ªßa t·∫•t c·∫£ c√°c phi√™n ƒë√£ ƒë∆∞·ª£c xu·∫•t!', 'success');
}

// --- CUSTOM UI COMPONENTS (MODAL, TOAST, PROMPT) ---
function showToast(message, type = 'info') {
    const container = document.getElementById('toast-container');
    const toast = document.createElement('div');
    const colors = {
        success: 'border-green-500', info: 'border-blue-500',
        warning: 'border-yellow-500', error: 'border-red-500'
    };
    toast.className = `toast-notification ${colors[type]}`;
    toast.textContent = message;
    container.appendChild(toast);
    setTimeout(() => { 
        toast.style.animation = 'fadeOut 0.5s ease';
        setTimeout(() => toast.remove(), 500);
    }, 3000);
}
/* S·ª¨A L·ªñI: X√≥a @keyframes kh·ªèi ƒë√¢y */

function showLoadingModal(message) {
    const container = document.getElementById('modal-container');
    container.innerHTML = `
        <div id="loading-modal" class="modal-backdrop">
            <div class="modal-content text-center">
                <p class="text-lg text-gray-200">${message}</p>
                <div class="mt-4">
                    <svg class="animate-spin h-8 w-8 text-white mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </div>
            </div>
        </div>`;
}
function hideLoadingModal() {
    const modal = document.getElementById('loading-modal');
    if (modal) {
        modal.style.animation = 'fadeOut 0.3s ease';
        setTimeout(() => {
             document.getElementById('modal-container').innerHTML = '';
        }, 300);
    } else {
        document.getElementById('modal-container').innerHTML = '';
    }
}
function showCustomConfirm(message, onConfirm) {
    const container = document.getElementById('modal-container');
    const modalHTML = `
        <div id="custom-confirm" class="modal-backdrop">
            <div class="modal-content">
                <p class="text-lg text-gray-200 mb-6">${message}</p>
                <div class="flex justify-end gap-4">
                    <button id="confirm-cancel" class="btn bg-gray-600 hover:bg-gray-500 px-6 py-2 rounded-lg">H·ªßy</button>
                    <button id="confirm-ok" class="btn bg-red-600 hover:bg-red-500 px-6 py-2 rounded-lg">X√°c nh·∫≠n</button>

                </div>
            </div>
        </div>
    `;
    container.innerHTML = modalHTML;
    const modalElement = document.getElementById('custom-confirm');
    document.getElementById('confirm-ok').onclick = () => { 
        onConfirm(); 
        modalElement.style.animation = 'fadeOut 0.3s ease';
        setTimeout(() => { container.innerHTML = ''; }, 300);
    };
    document.getElementById('confirm-cancel').onclick = () => { 
        modalElement.style.animation = 'fadeOut 0.3s ease';
        setTimeout(() => { container.innerHTML = ''; }, 300);
    };
}
function showCustomPrompt(message, defaultValue, onConfirm) {
    const container = document.getElementById('modal-container');
    const modalHTML = `
        <div id="custom-prompt" class="modal-backdrop">
            <div class="modal-content">
                <p class="text-lg text-gray-200 mb-4">${message}</p>
                <input type="text" id="prompt-input" value="${defaultValue}" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none mb-6">
                <div class="flex justify-end gap-4">
                    <button id="prompt-cancel" class="btn bg-gray-600 hover:bg-gray-500 px-6 py-2 rounded-lg">H·ªßy</button>
                    <button id="prompt-ok" class="btn bg-blue-600 hover:bg-blue-500 px-6 py-2 rounded-lg">L∆∞u</button>
                </div>
            </div>
        </div>
    `;
    container.innerHTML = modalHTML;
    const modalElement = document.getElementById('custom-prompt');
    const input = document.getElementById('prompt-input');
    input.focus();
    input.select();
    const closePrompt = (value) => {
        modalElement.style.animation = 'fadeOut 0.3s ease';
        setTimeout(() => { 
            container.innerHTML = '';
            if (value !== null) {
                onConfirm(value);
            }
         }, 300);
    };
    
    document.getElementById('prompt-ok').onclick = () => { closePrompt(input.value); };
    document.getElementById('prompt-cancel').onclick = () => { closePrompt(null); };
    input.onkeydown = (e) => { if (e.key === 'Enter') document.getElementById('prompt-ok').click(); };
}

function initializeApp() {
    state.sessions = getSessions();
    
    const defaultSimulation = {
        isActive: true, mode: 'follow', baseBet: 10,
        currentBet: 10, profitLoss: 0, log: [],
        stopLossLevel: 4,
        consecutiveLosses: 0,
        displayColumns: 6
    };

    Object.values(state.sessions).forEach(s => {
        if (!s.lengthPerformance) s.lengthPerformance = {};
        if (s.optimalLength === undefined) s.optimalLength = null;
        if (!s.verdictPredictions) s.verdictPredictions = []; 
        
        s.simulation = { ...JSON.parse(JSON.stringify(defaultSimulation)), ...s.simulation };
        s.simulation.isActive = true; // Force simulation on for all sessions
    });

    const lastActiveId = localStorage.getItem('lastActiveSession_v11_sim');
    if (Object.keys(state.sessions).length === 0) {
        createNewSession();
    } else {
        const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(a.split('-')[1]) - parseInt(a.split('-')[1]));
        const idToLoad = (lastActiveId && state.sessions[lastActiveId]) ? lastActiveId : sortedKeys[sortedKeys.length - 1]; // L·∫•y c√°i m·ªõi nh·∫•t
        state.currentSessionId = idToLoad;
        loadSession(idToLoad);
    }
    
    const sessionContent = document.getElementById('sessionManagementContent');
    sessionContent.style.maxHeight = sessionContent.scrollHeight + 'px';
    
    window.addEventListener('resize', () => {
        if(sessionContent.style.maxHeight && sessionContent.style.maxHeight !== '0px') {
            sessionContent.style.maxHeight = sessionContent.scrollHeight + 'px';
        }
    });
    
    document.getElementById('baseBet').addEventListener('change', (e) => updateSimSetting('baseBet', e.target.value));
    document.getElementById('stopLossLevel').addEventListener('change', (e) => updateSimSetting('stopLossLevel', e.target.value));
    document.getElementById('displayColumns').addEventListener('change', (e) => updateSimSetting('displayColumns', e.target.value));
    document.querySelectorAll('input[name="simMode"]').forEach(radio => {
        radio.addEventListener('change', (e) => updateSimSetting('mode', e.target.value));
    });
}

// --- INITIALIZATION ---
document.addEventListener('DOMContentLoaded', initializeApp)  
</script>
</body>
</html>

